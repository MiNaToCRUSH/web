# Большой список комманд для работы с **Git**


Это спискок основных комманд для git. Он подходит только для людей знакомых с git. Если вы новичёк вы вероятно большенство информации не поймете. [Снизу есть полезные ссылки](#полезные-ссылки)


## Работа с проэктом
`git init` Инициализация проэкта

`rm -rf .git` Удалить репозиторий .git(Отменить git init)

`git config --global user.name "[name]"` Смена имени

`git config --global user.email "[e-mail]"` Смена почты

`git remote add origin https://github.com/[your-link].git` Ссылка на сервер(origin)


## Работа с файлами
`git add ["." or files]` Добавление файлов в индекс
`git add -i` Показывает измененные куски файлов и спрашивает, что с ними сделать
`git diff` Просмотр изменений между файлами в индексе(сохраненном файле) и в рабочем дереве
`git diff --color-words` Цветной режим
`git diff --staged ` Просмотр изменений между файлами в индексе (staging area) и предыдущим коммитом
`git diff [file]` Просмотреть изменения, внесённые только в этот файл.
`git status` Текущее состояние репозитория (изменения, неразрешенные конфликты и тп)
`git restore` Отмена изменений в файлах
`git restore --staged` Отмена изменений подготовленных к коммиту
`git clean -fd` Очистка неотслеживаемых файлов
`git rm [file]` Удалить файл
`git mv [file1] [file2]` Переминование или перемещение файла(При указании пути [file2] файл будет пермещен туда с новым именем. Или файл будет просто переминован)
`git stash` Прячет изменения в рабочей директории. Вы можете продолжить работу закомитить новые изменения. Может быть вызвана несколько раз
`git stash pop` Возвращает изменения git stash
`git tag [tag] [commit]` Создать тег для коммита(На тег можно перейти с помощью checkout)
`git describe [ref]` Где ref — это что-либо, что указывает на конкретный коммит. Команда выведет tag_numCommits_g-hash


## Работа с коммитами
`git commit -m "[message]"` Коммит и коментарий
`git commit --amend -m "[message]"` Отредактировать сообщение предыдущего коммита
`git commit --amend --no-edit` Внести в коммит поправку без изменения сообщения коммита
`git commit` Коммит и редактор для сообщения
`git commit -am` Коммит с одновременным добавлением всего в индекс
`git checkout .` Отмена всех изминений до предыдущего коммита
`git show [hash]` Изменения, сделанные в заданном коммите
`git blame [file]` Изменения в каждой строчке кто их сделал и в каком коммите
`git grep [string]` Ищет совпадение с указанной строкой во всех файлах проекта
`git grep -i [string]` Без учета регистра
`git revert HEAD` Создасть новый коммит, содержащий обратные преобразования относительно HEAD(Вместо HEAD может быть имя коммита)
`git reset HEAD` Удалить файл(ы) из истории коммитов и перенести его в рабочую директорию(Вместо HEAD может быть имя коммита)
`git reset --hard HEAD` Удалить файл(ы) из истории коммитов
`git cherry-pick [commit1]...` Копировать несколько(или один) коммитов на место, где сейчас находишься
`git rebase -i HEAD~4` Открывает окно перемещения и изменения коммитов
`git log` Посмотреть все коммиты
`git log --graph --oneline --decorate` Историю коммитов в виде графика для текущей ветки
`git log --all --graph --oneline --decorate` Историю коммитов в виде графика для всех веток


## Перемещение между коммитами
`git checkout [hash]` Перейти в коммит по хешу
`git checkout main^` Перейти в предыдущий коммит от ветки main(Вы можите указывать ^ несколько раз для поднятия на несколько уровней)
`git checkout main^^` Перейти на 2 родителся от ветки main(Вы можите указывать ^ несколько раз для поднятия на несколько уровней)
`git checkout HEAD~1` Перейти в предыдущий коммит от HEAD(Вы можите указывать любое число для поднятия на несколько уровней)(Вместо HEAD может быть имя ветки)
`git checkout HEAD~^2~2 ` Все модификаторы можно обьеденять
`git branch -f main HEAD~3` Переместит (принудительно) ветку main на три родителя назад от HEAD(Вместо HEAD может быть имя ветки)



## Работа с ветками
`git branch [new_branch_name]` Создать новую ветку
`git checkout -b [new_branch_name]` Создать новую ветку и сразу перейти на неё
`git checkout [some_branch]` Переключиться на другую ветку
`git branch` Получаем список веток
`git branch` -a Список веток + удаленные
`git merge some_branch` Замерджить(обьеденить) some_branch в текущую ветку
`git merge --abort` Прервать слияние в случае конфликта
`git rebase [branch_to] [branch_from]` Перенести ветку в другую ветку. Предыдущая ветка становится неактивной(branch_from можно не указывать автоматически это будет текущая ветка)
`git branch -d some_branch` Удалить ветку (после мерджа(слиянья с другой веткой))
`git branch -D some_branch` Просто удалить ветку (тупиковая ветвь)
`git push origin --delete branch_name` Удалить ветку с сервера


## Работа с удалённым сервером
`git clone` Копирует все данные с сервера на локальный компьютер
`git push origin` Отправить все ветки локального репозитория на удаленный репозиторий 
`git push origin [branch]:[branch-on-server]` Отправить branch на branch-on-server(Если branch-on-server не существует она будет создана)(Вы можите указать 1 аргумент(любой))(Если не указать branch то branch-on-server будет удалена)
`git push origin HEAD` Запушить текущую ветку, не вводя целиком ее название
`git fetch [branch-on-server]:[branch]` Скопировать branch-on-server(Если branch не существует она будет создана)(Вы можите указать 1 аргумент(любой))(Если не указать branch-on-server то branch будет создана)
`git pull origin` Замерджить все ветки с удаленного репозитория с помощью merge
`git pull --rebase` То же но с помощью rebase
`git pull origin [branch-on-server]:[branch]` Замерджить branch-on-server(Если branch не существует она будет создана)(Вы можите указать 1 аргумент(любой))(Если не указать branch-on-server то branch будет создана)
`git pull origin HEAD` Замерджить текущую ветку, не вводя ее длинное имя
`Pull request` Просьба запушить изменения в заблокированую ветвь
`git checkout -b [branch] [branch-on-server]` Создает ветеку и привязывает ее к удаленной ветке
`git branch -u [branch-on-server] [branch]` То же самое


## Поиск ошибок
`git bisect` Испотльзуется для поиска ошибок в проэкте. Он использует бинарный поиск для того что бы найти ошибку
`git bisect` start запускает режим bisect
`git bisect bad` — говорит bisect, что в текущем HEAD мы уже наблюдаем регрессию
`git bisect good [commit]` — говорит bisect о последнем "хорошем" коммите, когда приложение работало правильно
Когда вы уже начали поск вы должны проверять проэкт на ошибки в вашей директории. Если проэкт работает пришите git bisect good если  ошибка все еще есть git bisect bad


## Игнорирование файлов
`touch .gitignore` Создать файл .gitignore``
`[file]` Игнорируем файл в любой директории проекта
`[directory]/` Игнорируем директорию в любой директории проекта
`/[directory]` Игнорируем каталог в корне рабочей директории
`*.[extension]` Игнорируем все файлы с расширением extention
`[directory]/**/*.[extension]` Игнорируем все файлы с расширением extention директории directory на всех уровнях вложенности


## Полезные ссылки
[Документация git](https://git-scm.com/book/ru/v2/%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-C%3A-%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B)
[Отличный визуальный сайт + конструктор](https://learngitbranching.js.org/?locale=ru_RU)
[Хороший курс от hexlet](https://ru.hexlet.io/courses/intro_to_git/lessons/open-source/theory_unit)
А также [книга по git](https://git-scm.com/book/ru/v2)


`ls -a` Содержимое
